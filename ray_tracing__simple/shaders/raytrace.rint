/*
 * Copyright (c) 2019-2021, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-FileCopyrightText: Copyright (c) 2019-2021 NVIDIA CORPORATION
 * SPDX-License-Identifier: Apache-2.0
 */

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#include "raycommon.glsl"
#include "wavefront.glsl"


hitAttributeEXT bool _isHit;

layout(set = 0, binding = eImplicit, scalar) buffer allVoxels_
{
  Voxel allVoxels[];
};

layout(set = 0, binding = eImplicitTLAS, scalar) buffer allTLAS_
{
  VoxelChunk allTLAS[];
};

layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };


struct Ray
{
  vec3 origin;
  vec3 direction;
};

// Ray-Voxel intersection
// http://viclw17.github.io/2018/07/16/raytracing-ray-voxel-intersection/

bool isTooFar(const Aabb aabb, const vec3 cameraPos) 
{
  // distance > maxDistance?
  float distanceMin = sqrt(pow(aabb.minimum.x - cameraPos.x, 2) + pow(aabb.minimum.y - cameraPos.y, 2) + pow(aabb.minimum.z - cameraPos.z, 2));
  float distanceMax = sqrt(pow(aabb.minimum.x - cameraPos.x, 2) + pow(aabb.minimum.y - cameraPos.y, 2) + pow(aabb.minimum.z - cameraPos.z, 2));
  if(distanceMin > pcRay.maxDistance && distanceMax > pcRay.maxDistance)
    return true;
  else
    return false;
}

// Ray-AABB intersection
float hitAabb(const Aabb aabb, const Ray r)
{
  vec3  invDir = 1.0 / r.direction;
  vec3  tbot   = invDir * (aabb.minimum - r.origin);
  vec3  ttop   = invDir * (aabb.maximum - r.origin);
  vec3  tmin   = min(ttop, tbot);
  vec3  tmax   = max(ttop, tbot);

  float t0     = max(tmin.x, max(tmin.y, tmin.z));
  float t1     = min(tmax.x, min(tmax.y, tmax.z));
  return t1 > max(t0, 0.0) ? t0 : -1.0;
}

void main()
{
  Ray ray;
  ray.origin    = gl_WorldRayOriginEXT;
  ray.direction = gl_WorldRayDirectionEXT;
  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);

  // Voxel data
  Voxel voxel = allVoxels[gl_PrimitiveID];
  VoxelChunk chunk = allTLAS[gl_InstanceCustomIndexEXT];
  debugPrintfEXT("TLAS pos x: %d, y: %d, z: %d\n", chunk.pos.x, chunk.pos.y, chunk.pos.z);

    float tHit    = -1;
    int   hitKind = 0;
    _isHit = false;
    {
        // AABB intersection
        Aabb aabb;
        aabb.minimum = (chunk.pos + voxel.center) - vec3(voxel.side);
        aabb.maximum = (chunk.pos + voxel.center) + vec3(voxel.side);
        //aabb.minimum = voxel.center - vec3(voxel.side);
        //aabb.maximum = voxel.center + vec3(voxel.side);
        if(!isTooFar(aabb, origin.xyz)) {
            highp float discretDistance = pcRay.maxDistance / voxel.maxLevel;
            tHit         = hitAabb(aabb, ray);
            hitKind =  int(voxel.maxLevel - tHit / discretDistance);
            hitKind = (hitKind < voxel.maxLevel) ? hitKind + 1 : hitKind;
            if(hitKind < voxel.level) 
            {
                hitKind = 0;
            } else {
                _isHit = true;
            }
        } 
    }

    // Report hit point
    if(_isHit)
        reportIntersectionEXT(tHit, hitKind);
}